import java.util.Properties

plugins {
    id 'java'
    id 'application'
}

group = 'com.lmco.crt'
version = '1.0-SNAPSHOT'

repositories {
    mavenCentral()
    mavenLocal()
}

application {
    mainClassName = 'com.lmco.crt.CodeReachabilityAnalyzer'
}

sourceSets {
    main {
        java {
            srcDirs = ['src/main/java']
        }
        resources {
            srcDirs = ['src/main/resources']
        }
    }
}

dependencies {
    implementation 'org.ow2.asm:asm:7.2'
    implementation 'org.ow2.asm:asm-tree:7.2'
    implementation 'org.apache.commons:commons-compress:1.19'
    testImplementation 'org.springframework.boot:spring-boot-starter-test:2.2.7.RELEASE'
}

test {
    useJUnitPlatform()
    maxHeapSize = "2g" // Set this to the desired heap size
    jvmArgs "-Xmx2g" // You can adjust the size according to your needs
}

// Load properties from gradle.properties
ext {
    analysisType = project.hasProperty('analysis.type') ? project.property('analysis.type') : 'MAIN'
}

// Define a task to write properties to config.properties
task writeConfigProperties {
    doLast {
        // Define the path to your config.properties file
        def configFile = file('src/main/resources/config.properties')

        // Create the file if it doesn't exist
        if (!configFile.exists()) {
            configFile.parentFile.mkdirs()
            configFile.createNewFile()
        }

        // Load existing properties
        Properties props = new Properties()
        if (configFile.exists()) {
            configFile.withInputStream { stream ->
                props.load(stream)
            }
        }

        // Set or update the property
        props.setProperty('analysis.type', analysisType)

        // Save the properties back to the file
        configFile.withOutputStream { stream ->
            props.store(stream, null)
        }
    }
}

// Ensure the properties are written before the Java application runs
tasks.processResources.dependsOn writeConfigProperties

// Add the below task to the build.gradle of the source code you want to analyze to create a fat jar.

// Define a task to assemble a fat JAR
//task fatJar(type: Jar) {
//    manifest {
//        attributes 'Main-Class': mainClassName
//    }
//    archiveBaseName.set("${project.name}-all")
//    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
//    with jar
//    // Handle duplicate entries
//    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
//}
//
//// Make the fat JAR the default artifact
//artifacts {
//    archives fatJar
//}

// **** MAIN JAR EXAMPLE ****
//task mainJar(type: Jar) {
//    from {
//        sourceSets.main.output
//    }
//    archiveBaseName.set('crt-service')
//    archiveVersion.set('1.0-SNAPSHOT')
//    exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'
//}
//
//// **** TEST JAR EXAMPLE ****
//task testJar(type: Jar) {
//    from {
//        sourceSets.test.allSource
//    }
//    archiveBaseName.set('crt-service-test')
//    archiveVersion.set('1.0-SNAPSHOT')
//    exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'
//}
//
//// Make sure the test classes are compiled before creating the JAR
//testJar.dependsOn(testClasses)