import java.util.Properties

plugins {
    id 'java'
    id 'application'
}

group = 'com.lmco.crt'
version = '1.0-SNAPSHOT'

repositories {
    mavenCentral()
    mavenLocal()
}

application {
    // Replace 'com.example.Main' with your main class name
    mainClassName = 'com.lmco.crt.CodeReachabilityAnalyzer'
}

sourceSets {
    main {
        java {
            srcDirs = ['src/main/java']
        }
        resources {
            srcDirs = ['src/main/resources']
        }
    }
}

dependencies {
    implementation 'org.ow2.asm:asm:7.2'
    implementation 'org.ow2.asm:asm-tree:7.2'
    implementation 'org.apache.commons:commons-compress:1.19'
    //testImplementation 'com.lmco.crt:crt-test-dependencies:0.4.0'
//    testImplementation platform('org.junit:junit-bom:5.9.1')
//    testImplementation 'org.junit.jupiter:junit-jupiter'
}

test {
    useJUnit()
}

// Load properties from gradle.properties
ext {
    analysisType = project.hasProperty('analysis.type') ? project.property('analysis.type') : 'MAIN'
}

// Define a task to write properties to config.properties
task writeConfigProperties {
    doLast {
        // Define the path to your config.properties file
        def configFile = file('src/main/resources/config.properties')

        // Create the file if it doesn't exist
        if (!configFile.exists()) {
            configFile.parentFile.mkdirs()
            configFile.createNewFile()
        }

        // Load existing properties
        Properties props = new Properties()
        if (configFile.exists()) {
            configFile.withInputStream { stream ->
                props.load(stream)
            }
        }

        // Set or update the property
        props.setProperty('analysis.type', analysisType)

        // Save the properties back to the file
        configFile.withOutputStream { stream ->
            props.store(stream, null)
        }
    }
}

// Ensure the properties are written before the Java application runs
tasks.processResources.dependsOn writeConfigProperties

// Add the below task to the build.gradle of the source code you want to analyze to create a fat jar.

// Define a task to assemble a fat JAR
//task fatJar(type: Jar) {
//    manifest {
//        attributes 'Main-Class': mainClassName
//    }
//    archiveBaseName.set("${project.name}-all")
//    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
//    with jar
//    // Handle duplicate entries
//    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
//}
//
//// Make the fat JAR the default artifact
//artifacts {
//    archives fatJar
//}